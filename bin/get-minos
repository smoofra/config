#!/usr/bin/env python3

from macholib import mach_o
from macholib.MachO import MachO, MachOHeader
import argparse
from typing import *
import subprocess
import os
import re
import ctypes
import ctypes.util
from collections import namedtuple


parser = argparse.ArgumentParser()
parser.add_argument("filename", metavar="MACHO_FILE")
parser.add_argument('-v', '--verbose', action='store_true')
args = parser.parse_args()

libc = ctypes.cdll[cast(str, ctypes.util.find_library('c'))]

class NXArchInfo(ctypes.Structure):
    _fields_ = [
        ('name', ctypes.c_char_p),
        ('cputype', ctypes.c_int),
        ('cpusubtype', ctypes.c_int),
        ('byteorder', ctypes.c_int),
        ('description', ctypes.c_char_p)]


NXGetArchInfoFromCpuType = libc.NXGetArchInfoFromCpuType
NXGetArchInfoFromCpuType.restype = ctypes.POINTER(NXArchInfo)
NXGetArchInfoFromCpuType.argtypes = [ ctypes.c_int, ctypes.c_int ]

def get_archname(header: MachO):
    h = header.header
    archinfo = NXGetArchInfoFromCpuType(h.cputype, h.cpusubtype)
    if archinfo:
        return archinfo.contents.name.decode('utf8')
    else:
        return f"{hex(h.cputype)}/{hex(h.cpusubtype)}"


def iter_platforms() -> Iterable[Tuple[int,str]]:
    sdk = subprocess.run(['xcrun', '-sdk', 'macosx', '--show-sdk-path'],
        stdout=subprocess.PIPE, check=True, encoding='utf8').stdout.strip()
    with open(os.path.join(sdk, 'usr', 'include', 'mach-o', 'loader.h'), 'r') as f:
        for line in f:
            if m := re.match(r'\s*#\s*define\s+PLATFORM_([^\s]+)\s+(\d.*)', line):
                yield int(m.group(2)), m.group(1).strip().lower()

try:
    platforms = dict(iter_platforms())
except OSError:
    platforms = {1: 'macos', 2: 'ios', 3: 'tvos', 4: 'watchos'}

Platform = str
Version = str

def decode_version(version:int) -> str:
    # X.Y.Z is encoded in nibbles xxxx.yy.zz
    a = version >> 16
    b = (version >> 8) & 0xff
    c = version & 0xff
    if c:
        return f"{a}.{b}.{c}"
    else:
        return f"{a}.{b}"

class PlatVer(NamedTuple):
    platform: str
    version: str

def get_vers(header:MachOHeader) -> Iterable[PlatVer]:
    for lc,cmd,data in header.commands:
        if isinstance(cmd,mach_o.version_min_command):
            lcname = mach_o.LC_NAMES[lc.cmd]
            m = re.match('LC_VERSION_MIN_(.*)', lcname)
            assert m
            platform_name = m.group(1).lower()
            platform_name = {"macosx":"macos", "iphoneos":"ios"}.get(platform_name, platform_name)
            yield PlatVer(platform_name, decode_version(cmd.version))
        elif lc.cmd == mach_o.LC_BUILD_VERSION:
            if s := platforms.get(cmd.platform):
                platform_name = s
            else:
                platform_name = f"unknown_platform_{cmd.platform}"
            yield PlatVer(platform_name, decode_version(cmd.minos))


def get_all_vers(macho:MachO) -> Iterable[Tuple[MachOHeader, Tuple[PlatVer, ...]]]:
    for header in macho.headers:
        yield header, tuple(sorted(get_vers(header), key=lambda x: x.platform))

all_vers = dict(get_all_vers(MachO(args.filename)))

unique_vers = set(all_vers.values())

if not args.verbose and len(unique_vers) == 1:
    for ver in next(iter(unique_vers)):
        print(f"{ver.platform}: {ver.version}")
else:
    for header, vers in all_vers.items():
        print(get_archname(header))
        for ver in vers:
            print(f"    {ver.platform}: {ver.version}")
