#!/usr/bin/env python3

import os
import sys
from contextlib import contextmanager
import subprocess
import shlex
from typing import ContextManager, Generator, List, Optional, Tuple, Any, Dict, cast, Iterator
from typing_extensions import Self
import argparse
import json
from textwrap import dedent

FNULL = open(os.devnull, 'w')

# Suspend execution and save a stack of continuations in .git/swap.json
class Suspend(BaseException):
    continuations: List['Continuation']
    status: Optional[str]
    def __init__(self) -> None:
        self.continuations = list()
        self.status = None


class Abort(Exception):
    pass

# raised into a resume stack by git-swap --stop
class Stop(Exception):
    pass

# raised into a resume stack by git-swap --squash
class Squash(Exception):
    pass

class GitFailed(Exception):
    pass

class SwapFailed(Exception):
    pass

# A metaclass for continuation types.  This just collects a dict of them all
# indexed by name.
class ContinuationClass(type):
    types : Dict[str, 'ContinuationClass'] = dict()
    def __new__(cls, name, bases, attrs):
        T = type.__new__(cls, name, bases, attrs)
        cls.types[name] = T
        return T


# A continuation is  is a context manager that can suspended, serialized out to
# json, and then resumed in a subsequent execution of this program.
class Continuation(metaclass=ContinuationClass):

    manager : ContextManager[None]
    git : 'Git'

    def __init__(self, git: 'Git') -> None:
        self.git = git

    def __enter__(self) -> None:
        self.manager = self.impl()
        return self.manager.__enter__()

    def __exit__(self, typ, value, traceback) -> bool | None:
        if typ and issubclass(typ, Suspend):
            if value is None:
                value = typ()
            value.continuations.append(self)
            return None
        else:
            return self.manager.__exit__(typ, value, traceback)

    def impl(self) -> ContextManager[None]:
        # any initialization that occurs before yield should be done in __init__, not here
        raise NotImplementedError

    @classmethod
    def resume(cls, git: 'Git', *, abort:bool = False, stop:bool = False, squash:bool = False) -> None:

        def r(ks: List[Dict]) -> None:
            if not len(ks):
                if abort:
                    raise Abort
                elif stop:
                    raise Stop
                elif squash:
                    raise Squash
                else:
                    return
            [k, *ks] = ks
            T = ContinuationClass.types[k['kind']]
            del k['kind']
            with T(git, **k):
                r(ks)

        with open(git.swap_json, 'r') as f:
            j = json.load(f)
        os.unlink(git.swap_json)

        with cls.main(git):
            try:
                r(j['continuations'])
            except Abort:
                pass

    @staticmethod
    @contextmanager
    def main(git: 'Git') -> Iterator[None]:
        if os.path.exists(git.swap_json):
            raise Exception("git-swap operation is already in progress")
        try:
            yield
        except Suspend as e:
            if e.status:
                print(e.status)
            print(" === Suspended!  Resolve conflicts and run: git swap --continue ==")
            with open(git.swap_json, 'w') as f:
                ks = [k.to_json_dict() for k in reversed(e.continuations)]
                j : Dict
                j = {"continuations": ks}
                if e.status:
                    j["status"] = e.status
                json.dump(j, f, indent=True)
                f.write("\n")

    @staticmethod
    def status(git: 'Git') -> None:
        if os.path.exists(git.swap_json):
            with open(git.swap_json, 'r') as f:
                print(json.load(f).get("status", "unknown"))
        else:
            print("no swap operation in progress")


    def to_json_dict(self) -> Dict:
        j = self.__dict__
        j['kind'] = self.__class__.__name__
        del j['manager']
        del j['git']
        return j


class EditBranch(Continuation):

    def __init__(self, git: 'Git', *, head: Optional[str] = None) -> None:
        super().__init__(git)
        if head:
            self.head = head
        else:
            self.head = git.head()
            git.detach()

    @property
    def branch(self) -> Optional[str]:
        if self.head.startswith("refs/heads/"):
            return self.head.removeprefix("refs/heads/") or None
        return None

    @contextmanager
    def impl(self) -> Iterator[None]:
        try:
            yield
        except Exception:
            self.git.force_checkout(self.branch or self.head)
            raise
        else:
            if self.branch:
                self.git.cmd(['git', 'update-ref', '-m', 'git-swap', self.head, 'HEAD'])
                self.git.checkout(self.branch)


class PickCherries(Continuation):

    def __init__(self, git: 'Git', *, cherries: List[str]):
        super().__init__(git)
        self.cherries = cherries

    @contextmanager
    def impl(self) -> Iterator[None]:
        yield
        for cherry in self.cherries:
            self.git.cherry_pick(cherry)


# pick a cherry, resolving conflicts using a reference commit
class PickCherryWithReference(Continuation):

    def __init__(self, git:'Git', *, cherry:str, reference:str):
        super().__init__(git)
        self.cherry = cherry
        self.reference = reference

    @contextmanager
    def impl(self) -> Iterator[None]:
        yield
        ok = False
        try:
            try:
                self.git.cmd(["git", "cherry-pick", self.cherry], stderr=FNULL)
                ok = True
            except GitFailed:
                if self.git.conflicted:
                    self.git.cmd(['git', 'checkout', self.reference, '.'])
                    self.git.cmd(['git', 'cherry-pick', '--continue'])
                    ok = True
                else:
                    raise
        finally:
            if not ok:
                self.git.cmd(['git', 'cherry-pick', '--abort'])


class CherryPickContinue(Continuation):

    def __init__(self, git:'Git'):
        super().__init__(git)

    @contextmanager
    def impl(self) -> Iterator[None]:
        try:
            yield
        except Exception:
            self.git.cmd(['git', 'cherry-pick', '--abort'])
            raise
        else:
            if self.git.conflicted:
                self.git.cmd(['git', 'cherry-pick', '--continue'])


class OrSquash(Continuation):

    def __init__(self, git:'Git'):
        super().__init__(git)

    @staticmethod
    def edit():
        (_, _, A, B, path) = sys.argv
        with open(path, "w") as f:
            print("pick", A, file=f)
            print("squash", B, file=f)

    @contextmanager
    def impl(self) -> Iterator[None]:
        squash = False
        try:
            yield
        except Squash:
            squash = True
        if squash:
            A = self.git.commit("HEAD")
            B = self.git.unique_parent(A)
            C = self.git.unique_parent(B)
            try:
                self.git.cmd(['git', '-c', f"sequence.editor={sys.executable} {__file__} --edit-rebase {B.sha} {A.sha}", 'rebase', '-i', C.sha], interactive=True)
            except GitFailed:
                self.git.cmd(['git', 'rebase', '--abort'])
                raise
            raise Stop


class Checkpoint(Continuation):

    def __init__(self, git:'Git', head:str):
        super().__init__(git)
        self.head = head

    @contextmanager
    def impl(self) -> Iterator[None]:
        try:
            yield
        except Exception:
            self.git.force_checkout(self.head)
            raise


# after ...AB as been swapped to ...BA, keep trying to push B down further
class KeepGoing(Continuation):

    def __init__(self, git:'Git', *, edit:bool = False):
        super().__init__(git)
        self.edit = edit

    @contextmanager
    def impl(self) -> Iterator[None]:
        try:
            yield #swap
        except Abort:
            raise
        except (SwapFailed, Stop):
            print("this far and no further!")
            return
        A = self.git.commit("HEAD")
        B = self.git.unique_parent(A)
        self.git.checkout(B.sha)
        with PickCherries(self.git, cherries=[A.sha]):
            with KeepGoing(self.git, edit=self.edit):
                self.git.swap(edit=self.edit)


@contextmanager
def maybe_keep_going(keep_going:bool, *, edit:bool, git:'Git') -> Iterator[None]:
    if keep_going:
        with KeepGoing(git, edit=edit):
            yield
    else:
        yield


class Git:

    def __init__(self, directory=None):
        if directory is None:
            directory = '.'
        self.directory = directory
        self.directory = self.cmd("git rev-parse --show-toplevel".split(), quiet=True).strip()
        if self.directory == '':
            raise Exception("can't find top-level.  (bare repo?)")
        self.gitdir = self.cmd("git rev-parse --git-dir".split(), quiet=True).strip()


    def cmd(self, args, *, quiet:bool = False, interactive:bool = False, **kw) -> str:
        if not quiet:
            print("+", ' '.join(map(shlex.quote, args)))
        if not interactive:
            kw['stdin'] = FNULL
            kw['stdout'] = subprocess.PIPE
        proc = subprocess.Popen(args, cwd=self.directory, encoding='utf8', **kw)
        (out, err) = proc.communicate()
        if proc.wait() != 0:
            raise GitFailed("git failed")
        return out

    def cmd_test(self, args, **kw) -> bool:
        proc = subprocess.Popen(args, cwd=self.directory, stdin=FNULL, **kw)
        code = proc.wait()
        if code not in [0,1]:
            raise GitFailed("git failed")
        return not code

    def rev_parse(self, commit: str) -> str:
        return self.cmd(['git', 'rev-parse', commit], quiet=True).strip()


    def detach(self) -> None:
        self.cmd(['git', 'checkout', self.rev_parse('HEAD')], stderr=FNULL)

    def head(self) -> str:
        try:
            return self.cmd(['git', 'symbolic-ref', 'HEAD'], quiet=True).strip()
        except GitFailed:
            return self.rev_parse('HEAD')

    def force_checkout(self, branch: str) -> None:
        self.cmd(['git', 'checkout', '-f', branch], stderr=FNULL)

    def commit(self, ref:str) -> 'Commit':
        return Commit(self, ref)

    def checkout(self, branch: str) -> None:
        self.cmd(['git', 'checkout', branch], stderr=FNULL)

    @property
    def swap_json(self) -> str:
        return os.path.join(self.gitdir, 'swap.json')

    def is_clean(self) -> bool:
        return ('' == self.cmd("git diff-index --cached --name-only HEAD".split(), quiet=True) and
                '' == self.cmd("git diff-files --name-only".split(), quiet=True))

    def cherry_pick(self, ref:str, edit:bool = False) -> None:
        try:
            self.cmd(['git', 'cherry-pick', ref])
            new_one = self.rev_parse('HEAD')
        except GitFailed:
            if edit and self.conflicted:
                raise Suspend
            else:
                self.cmd(['git', 'cherry-pick', '--abort'])
                raise

    @property
    def conflicted(self) -> bool:
        return os.path.exists(os.path.join(self.gitdir, "CHERRY_PICK_HEAD"))

    def unique_parent(self, commit: 'Commit') -> 'Commit':
        if len(commit.parents) != 1:
            raise Exception(f"{commit} is a merge")
        return self.commit(commit.parents[0])

    def swap(self, *, edit:bool = False) -> None:
        with OrSquash(self):
            one = self.commit("HEAD")
            two = self.unique_parent(one)
            three = self.unique_parent(two)
            try:
                with Checkpoint(self, head=one.sha):
                    self.checkout(three.sha)
                    with PickCherryWithReference(self, cherry=two.sha, reference=one.sha):
                        try:
                            self.cherry_pick(one.sha, edit=edit)
                        except Suspend as e:
                            e.status = dedent(f"""
                            Attempting to swap:
                              {one.summary}
                              {two.summary}
                            """)
                            raise
            except Exception as e:
                raise SwapFailed from e


    def swap_commit(self, commit:str, *, edit:bool = False, keep_going:bool = False) -> None:
        sha = self.rev_parse(commit)
        cherries: List[str] = list()
        head = self.commit('HEAD')
        while True:
            if head.sha == sha:
                break
            cherries.append(head.sha)
            head = self.unique_parent(head)
        self.checkout(sha)
        with PickCherries(self, cherries=cherries):
            with maybe_keep_going(keep_going, git=self, edit=edit):
                self.swap(edit=edit)


class Commit(object):

    parents : List[str]

    def __init__(self, git : Git, rev:str):
        self.parents = list()
        buffer = git.cmd("git log -n1 --no-notes --pretty=raw".split() + [rev], quiet=True)
        (headers, message) = buffer.split("\n\n", 1)
        for header in headers.split("\n"):
            (key, value) = header.strip().split(' ', 1)
            if key == 'commit':
                self.sha = value
            if key == 'parent':
                self.parents.append(value)
            if key == 'tree':
                self.tree = value
            if key == 'author':
                self.author = value
            if key == 'committer':
                self.committer = value
        assert message.endswith('\n')
        lines = message[:-1].split('\n')
        assert all(x.startswith('    ') for x in lines)
        lines = [x[4:] for x in lines]
        self.message = '\n'.join(lines) + '\n'

    @property
    def summary(self) -> str:
        m, _ = self.message.split('\n', 1)
        return f"{self.sha[:10]} {m}"

    def __str__(self) -> str:
        return self.sha[:10]


def main() -> None:

    if len(sys.argv) > 1 and sys.argv[1] == "--edit-rebase":
        OrSquash.edit()
        return

    parser = argparse.ArgumentParser()
    parser.add_argument("--keep-going", "-k", action='store_true', help="push HEAD as far down the stack as it will go")
    parser.add_argument("--continue", action='store_true', dest="resume")
    parser.add_argument("--abort", action='store_true')
    parser.add_argument("--stop", action='store_true', help="abandon the latest swap operation")
    parser.add_argument("--squash", action='store_true', help="squash instead of completing this swap")
    parser.add_argument("--edit", "-e", action="store_true")
    parser.add_argument("--status", action="store_true")
    parser.add_argument("commit", nargs='?')
    args = parser.parse_args()

    if sum(bool(x) for x in (args.resume,args.abort,args.stop, args.squash, args.status)) > 1:
        parser.error("use only one of --continue, --abort, --stop, --status, or --squash")

    git = Git()

    if args.status:
        Continuation.status(git)
        return

    if args.resume or args.abort or args.stop or args.squash:
        Continuation.resume(git, abort=args.abort, stop=args.stop, squash=args.squash)
        return

    if not git.is_clean():
        raise Exception("repo not clean")

    with Continuation.main(git):
        with EditBranch(git):
            if args.commit:
                git.swap_commit(args.commit, edit=args.edit, keep_going=args.keep_going)
            else:
                with maybe_keep_going(args.keep_going, git=git, edit=args.edit):
                    git.swap(edit=args.edit)


if __name__ == "__main__":
    main()