#!/usr/bin/python

import re
import sys
from collections import defaultdict
from errno import EPIPE


class peekiter(object):

    def __init__(self, x):
        self._iter = iter(x)
        self._peek = None

    def __iter__(self):
        return self

    def next(self):
        if self._peek is not None:
            ret = self._peek
            self._peek = None
            return ret
        else:
            return self._iter.next()

    def peek(self):
        if self._peek is None:
            self._peek = self._iter.next()
        return self._peek


def peekmatch(iterator, regex, flags=0):
    try:
        peek = iterator.peek()
    except StopIteration:
        return False
    return re.match(regex, peek, flags)


def first(gen):
    for x in gen:
        if x:
            return x
    return None


class Log(object):

    @classmethod
    def guess_logtype(cls, header):
        subs = [sub for sub in cls.__subclasses__() if re.match(sub.header_regex, header)]
        if len(subs) == 1:
            return subs[0]
        if len(subs) == 0:
            raise Exception("unrecognised log type")
        else:
            raise Exception("ambiguous log type")


    def read_threads_keep_going(self, lines):
        return True

    def read_threads(self, lines):

        while peekmatch(lines, self.thread_peek_regex):

            if not self.read_threads_keep_going(lines):
                return

            line = lines.next()

            if line.strip() == '':
                continue

            m = first(re.match(regex, line) for regex in self.thread_regexes)
            if not m:
                raise Exception("parse error: " + line.rstrip())

            indent = len(m.group('indent'))
            threadid = m.group('threadid')
            comment = m.group('comment')

            stacks = self.read_stacks(lines, indent)

            yield (threadid, comment, stacks)

    def read_stacks(self, lines, indent):

        indent_regex = '%s{%d}' % (self.indent_char_regex, indent + self.stack_indent_offset)

        name_stack = []
        indent_stack = []
        count_stack = []
        subcount_stack = []

        stacks = defaultdict(lambda : 0)

        def pop():
            stack = tuple(name_stack)

            count = count_stack.pop()
            subcount = subcount_stack.pop()
            name_stack.pop()
            indent_stack.pop()

            assert subcount <= count

            if subcount < count:
                stacks[stack] += count - subcount

            if len(subcount_stack):
                subcount_stack[-1] += count

        def push(name, indent, count):
            name_stack.append(name)
            indent_stack.append(indent)
            count_stack.append(count)
            subcount_stack.append(0)

        while peekmatch(lines, indent_regex):

            line = lines.next()

            m = re.match(self.stack_regex, line)
            if not m:
                raise Exception("parse error")

            indent = len(m.group('indent'))
            count =  int(m.group('count'))

            name = m.group('name')
            if name is None or name.strip() == '':
                name = m.group('address')

            while len(indent_stack) > 0 and indent <= indent_stack[-1]:
                pop()

            push(name, indent, count)

        while len(name_stack):
            pop()

        return stacks



class SampleLog(Log):

    #offset of indentation of first stack after the Thread line
    stack_indent_offset = 1

    indent_char_regex = r'[ \+\!\:\|]'

    stack_regex = re.compile(
        r' ^  (?P<indent>[ \+\!\:\|]+) (?P<count>\d+) \s+ ' +
        r'(\?\?\?)? \s* (?P<name>.*?) \s*' +
        r' (  \(in \s+ (?P<dylib>[^\s]+) \) \s+ (load \s+ address \s+ 0x[0-9a-f]+ \s+ )? \+ \s+ (?P<offset>\d+|0x[0-9a-f]+)  )? \s* ' +
        r'(?P<address>\[0x[0-9a-f]+\])? \s* $',
        re.IGNORECASE | re.VERBOSE)

    thread_regexes =[
        re.compile(x, re.IGNORECASE | re.VERBOSE) for x in
        (r' ^ (?P<indent>[ \+\!\:\|]+) (?P<count>\d+) \s+ Thread_(?P<threadid>\d+) \s* (?P<comment>.*?) \s*$',
         r' ^ (?P<indent>[ \+\!\:\|]+) (?P<count>\d+) \s+ Thread_\<multiple\> \s+ (?P<threadid> DispatchQueue_\d+) \s* (?P<comment>.*?) \s*$')]

    thread_peek_regex = r'^\s+[^\s]'

    header_regex = r'^Analysis of sampling (?P<name>.*?) \(pid (?P<pid>\d+)\) every'

    def find_threads(self, lines):

        for line in lines:
            if line.rstrip() == 'Call graph:':
                break
        else:
            raise Exception("parse error")

        return self.read_threads(lines)


    def find_procs(self, lines):

        line = lines.next()

        m = re.match(self.header_regex, line)
        if not m:
            raise Exception("parse error")

        name = m.group('name')
        pid = int(m.group('pid'))

        threads = self.find_threads(lines)

        yield (name, pid, threads)



class SpindumpLog(Log):

    #offset of indentation of first stack after the Thread line
    stack_indent_offset = 0

    indent_char_regex = r'[\ \*]'

    stack_regex = re.compile(
        r' ^  (?P<indent>[\ \*]+) (?P<count>\d+) \s* (\?\?\? \s*)? (?P<name>.*?) \s* (?P<address>\[0x[0-9a-f]+\])? \s* ' +
        r'(?P<running> \(running\) | \(suspended\))? \s* $ ',
        re.IGNORECASE | re.VERBOSE)

    thread_regexes = [
        re.compile(x, re.IGNORECASE | re.VERBOSE) for x in
        r' ^ (?P<indent> [\ \*]+) Thread \s+ (?P<threadid> 0x[a-f0-9]+) \s* (?P<comment>.*?) \s* $ ',
        r' ^ (?P<indent> [\ \*]+) Thread \s+ \<multiple\> \s+ (?P<threadid> DispatchQueue \s* \d+) \s* (?P<comment>.*?) \s* $ ']

    thread_peek_regex = re.compile(r'^( \s+ | $ )', re.VERBOSE)

    header_regex = r'^Date/Time:'

    def read_threads_keep_going(self, lines):
        return not lines.peek().strip() == 'Binary Images:'

    def find_procs(self, lines):

        while True:

            while not peekmatch(lines, '^Process:'):
                lines.next()

            metadata = dict()
            while peekmatch(lines, '^\w[\w\s]*\:'):
                key, value = lines.next().split(':', 2)
                metadata[key] = value.strip()


            m = re.match('^ (?P<name>.*?) \s+ \[ (?P<pid>\d+) \] \s* $',
                         metadata['Process'],
                         re.VERBOSE)
            if not m:
                raise Exception("parse error: " + metadata['Process'])

            name = m.group('name')
            pid = int(m.group('pid'))

            yield (name, pid, list(self.read_threads(lines)))



def write_stacks(stacks, prefix=()):
    for key, value in stacks.items():
        print ';'.join(prefix + key), value


with open(sys.argv[1], "r") as f:
    lines = peekiter(f)

    procs =  Log.guess_logtype(lines.peek())().find_procs(lines)
    (procname, pid, threads) = procs.next()

    try:
        for threadid, comment, stacks in threads:
            write_stacks(stacks, prefix=(str(threadid),))
    except IOError, e:
        if e.errno != EPIPE:
            raise
